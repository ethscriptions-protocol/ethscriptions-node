// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "@openzeppelin/contracts/proxy/Clones.sol";
import {LibString} from "solady/utils/LibString.sol";
import "./EthscriptionsERC20.sol";
import "./Ethscriptions.sol";
import "./libraries/Predeploys.sol";

contract TokenManager {
    using Clones for address;
    using LibString for string;

    struct TokenInfo {
        address tokenContract;
        bytes32 deployTxHash;
        string protocol;
        string tick;
        uint256 maxSupply;
        uint256 mintAmount;
        uint256 totalMinted;
    }
    
    struct TokenItem {
        bytes32 deployTxHash;  // Which token this ethscription belongs to
        uint256 amount;        // How many tokens this ethscription represents
    }

    address public constant erc20Template = Predeploys.ERC20_TEMPLATE;
    address public constant ethscriptions = Predeploys.ETHSCRIPTIONS;
    
    // Track deployed tokens by protocol+tick for find-or-create
    mapping(bytes32 => TokenInfo) public tokensByTick;  // keccak256(abi.encode(protocol, tick)) => TokenInfo
    mapping(bytes32 => bytes32) public deployToTick;     // deployTxHash => tickKey
    
    // Track which ethscription is a token item
    mapping(bytes32 => TokenItem) public tokenItems;  // ethscription tx hash => TokenItem
    
    event TokenDeployed(
        bytes32 indexed deployTxHash,
        address indexed tokenAddress,
        string tick,
        uint256 maxSupply,
        uint256 mintAmount
    );
    
    event TokenMinted(
        bytes32 indexed deployTxHash,
        address indexed to,
        uint256 amount,
        bytes32 ethscriptionTxHash
    );
    
    event TokenTransferred(
        bytes32 indexed deployTxHash,
        address indexed from,
        address indexed to,
        uint256 amount,
        bytes32 ethscriptionTxHash
    );

    modifier onlyEthscriptions() {
        require(msg.sender == ethscriptions, "Only Ethscriptions contract");
        _;
    }
    
    function _getTickKey(string memory protocol, string memory tick) private pure returns (bytes32) {
        return keccak256(abi.encode(protocol, tick));
    }

    /// @notice Handle token operation from Ethscriptions contract
    /// @dev Implements find-or-create pattern for deploy, direct mint for mint operations
    function handleTokenOperation(
        bytes32 ethscriptionTxHash,
        address initialOwner,
        Ethscriptions.TokenParams calldata params
    ) external virtual onlyEthscriptions {
        // Early return if not a token operation
        if (bytes(params.op).length == 0) return;
        
        bytes32 tickKey = _getTickKey(params.protocol, params.tick);
        TokenInfo storage token = tokensByTick[tickKey];
        
        if (keccak256(bytes(params.op)) == keccak256("deploy")) {
            // Revert if token already exists
            require(token.deployTxHash == bytes32(0), "Token already deployed");
            _deployToken(ethscriptionTxHash, tickKey, params.protocol, params.tick, params.max, params.lim);
        } else if (keccak256(bytes(params.op)) == keccak256("mint")) {
            // Token must exist to mint
            require(token.deployTxHash != bytes32(0), "Token not deployed");
            
            // Validate mint amount matches token's configured limit
            require(params.amt == token.mintAmount, "amt mismatch");
            
            // Track this ethscription as a token item (store raw amount from inscription)
            uint256 amount = params.amt;
            tokenItems[ethscriptionTxHash] = TokenItem({
                deployTxHash: token.deployTxHash,
                amount: amount
            });
            
            // Mint tokens to the initial owner - convert to 18 decimals
            // User amount "1000" means 1000 * 10^18 smallest units
            EthscriptionsERC20(token.tokenContract).mint(initialOwner, amount * 10**18);
            
            // Update total minted after successful mint
            token.totalMinted += amount;
            
            emit TokenMinted(token.deployTxHash, initialOwner, amount, ethscriptionTxHash);
            // Proofs will be automatically generated by EthscriptionsERC20._update
        }
    }

    /// @notice Handle token transfer when NFT is transferred
    function handleTokenTransfer(
        bytes32 ethscriptionTxHash,
        address from,
        address to
    ) external virtual onlyEthscriptions {
        TokenItem memory item = tokenItems[ethscriptionTxHash];
        if (item.deployTxHash == bytes32(0)) {
            // Not a token item, nothing to do
            return;
        }
        
        bytes32 tickKey = deployToTick[item.deployTxHash];
        TokenInfo storage token = tokensByTick[tickKey];
        
        // Force transfer tokens (shadow transfer) - convert to 18 decimals
        EthscriptionsERC20(token.tokenContract).forceTransfer(from, to, item.amount * 10**18);
        
        emit TokenTransferred(item.deployTxHash, from, to, item.amount, ethscriptionTxHash);
        // Proofs will be automatically generated by EthscriptionsERC20._update
    }

    function _deployToken(
        bytes32 deployTxHash,
        bytes32 tickKey,
        string calldata protocol,
        string calldata tick,
        uint256 maxSupply,
        uint256 mintAmount
    ) private {
        require(maxSupply > 0, "Invalid max supply");
        require(mintAmount > 0, "Invalid mint amount");
        require(maxSupply % mintAmount == 0, "Max supply must be divisible by mint amount");
        
        // Deploy ERC20 clone with CREATE2 using tickKey as salt for deterministic address
        address tokenAddress = erc20Template.cloneDeterministic(tickKey);
        
        // Initialize the clone
        string memory name = string.concat(protocol, " ", tick);
        string memory symbol = LibString.upper(tick);
        
        // Initialize with max supply in 18 decimals
        // User maxSupply "1000000" means 1000000 * 10^18 smallest units
        EthscriptionsERC20(tokenAddress).initialize(
            name,
            symbol,
            maxSupply * 10**18,
            deployTxHash
        );
        
        // Store token info
        tokensByTick[tickKey] = TokenInfo({
            tokenContract: tokenAddress,
            deployTxHash: deployTxHash,
            protocol: protocol,
            tick: tick,
            maxSupply: maxSupply,
            mintAmount: mintAmount,
            totalMinted: 0
        });
        
        // Map deploy hash to tick key for lookups
        deployToTick[deployTxHash] = tickKey;
        
        emit TokenDeployed(deployTxHash, tokenAddress, tick, maxSupply, mintAmount);
    }

    // View functions
    function getTokenAddress(bytes32 deployTxHash) external view returns (address) {
        bytes32 tickKey = deployToTick[deployTxHash];
        return tokensByTick[tickKey].tokenContract;
    }

    function getTokenAddressByTick(string calldata protocol, string calldata tick) external view returns (address) {
        bytes32 tickKey = _getTickKey(protocol, tick);
        return tokensByTick[tickKey].tokenContract;
    }

    function getTokenInfo(bytes32 deployTxHash) external view returns (TokenInfo memory) {
        bytes32 tickKey = deployToTick[deployTxHash];
        return tokensByTick[tickKey];
    }

    function getTokenInfoByTick(string calldata protocol, string calldata tick) external view returns (TokenInfo memory) {
        bytes32 tickKey = _getTickKey(protocol, tick);
        return tokensByTick[tickKey];
    }

    function predictTokenAddressByTick(string calldata protocol, string calldata tick) external view returns (address) {
        bytes32 tickKey = _getTickKey(protocol, tick);
        
        // Check if already deployed
        if (tokensByTick[tickKey].tokenContract != address(0)) {
            return tokensByTick[tickKey].tokenContract;
        }
        
        // Predict using CREATE2
        return Clones.predictDeterministicAddress(erc20Template, tickKey, address(this));
    }
    
    function isTokenItem(bytes32 ethscriptionTxHash) external view returns (bool) {
        return tokenItems[ethscriptionTxHash].deployTxHash != bytes32(0);
    }
    
    function getTokenAmount(bytes32 ethscriptionTxHash) external view returns (uint256) {
        return tokenItems[ethscriptionTxHash].amount;
    }
    
    function getTokenItem(bytes32 ethscriptionTxHash) external view returns (TokenItem memory) {
        return tokenItems[ethscriptionTxHash];
    }
}
